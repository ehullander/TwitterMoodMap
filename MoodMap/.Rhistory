}
makenormplot()
makenormplot(con=90)
?anova
LRpossum
.0936/(.088+.0936)
n=1000
.53*.51
.19/.51
## Put comments here that give an overall description of what your
## functions do
## makeCacheMatrix takes a matrix as input and returns a list of functions
## which will be used by cacheSolve
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(inv) m <<- inv
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## cacheSolve will return the inverse of a matrix 'x', taking the list
## makeCacheMatrix(x) as an input
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
mat <- x$get()
m <- solve(mat, ...)
x$setinverse(m)
m
}
test=matrix(2,2,1:4)
test
?matrix
test=matrix(1:4,2,2)
test
test=test-2
test
solve(test)
blob=makeCacheMatrix(test)
cacheSolve(blob)
cacheSolve(blob)
}
## The program will solve the inverse of a matrix and cache the result
## using a special matrix
## This function creates a special "matrix" object that can cache its inverse.
## It outputs a list of functions:
## set the value of the matrix
## get the value of the matrix
## set the value of the inverse matrix
## get the value of the inverse matrix
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- solve
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## This function computes the inverse of the special "matrix" returned by makeCacheMatrix above.
## If the inverse has already been calculated (and the matrix has not changed), then the
## cachesolve should retrieve the inverse from the cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
blob=makeCacheMatrix(test)
cacheSolve(blob)
cacheSolve(blob)
}
## This function uses a cached value for an inverse if it is available.
## This file contains two functions. First: makeCacheMatrix which creates a matrix with a functionality to store cached inverse.
## Egzample usage:
## Given a matrix named 'matrix' we can create a matrix with casched inverse like this:
## cachedMatrix <- makeCacheMatrix(matrix)
##
## Second function cacheSolve for a given matrix returns its inverse.
## If the matrix had a previously cached inverse, it is not calculated again
## and the cached value is returned. Egzample usage:
## inverseMatrix <- cacheSolve(cachedMatrix)
## A function to create a matrix with a cached inverse.
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(inverse) m <<- inverse
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Function calculates an inverse of a matrix passed as a parameter x.
## This function uses a cached value for an inverse if it is available.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data)
x$setinverse(m)
m
}
blob=makeCacheMatrix(test)
cacheSolve(blob)
cacheSolve(blob)
## These are a pair of functions that cache
## the inverse of a matrix.
## Function creates a list of functions
## which will be used to store the inverse.
makeCacheMatrix <- function(x = matrix()) {
#Matrix to store inverse matrix
inv <- NULL
#Function-substitutes matrix x with matrix y in main function
set <- function(y){
x <<- y
#sets old inverse matrix to null
inv <<- NULL
}
#Function-Retrieves the matrix given by main function
get <- function() x
#Function-stores value of the inverse into the main function
setinverse <- function(inverse) inv <<- inverse
#Function-Retrieves inverse matrix
getinverse <- function() inv
#List of the 4 functions
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Function computes the inverse of the matrix
## formed by makeCacheMatrix. First checks if
## the inverse has already been computed and
## computes inverse if it has not.
cacheSolve <- function(x, ...) {
inv <- x$getinverse()
#checking if inverse is already computed
if(!is.null(inv)){
message("getting cached data")
return(inv)
}
#if no inverse, gets matrix and computes inverse
data <- x$get()
inv <- solve(data,...)
#stores inverse in makeCacheMatrix
x$setinverse(inv)
inv
}
blob=makeCacheMatrix(test)
cacheSolve(blob)
cacheSolve(blob)
data(airquality)
str(airquality)
?split
split(airquality,airquality$Month)
s=split(airquality,airquality$Month)
str(s)
?scale
require(stats)
x <- matrix(1:10, ncol = 2)
(centered.x <- scale(x, scale = FALSE))
cov(centered.scaled.x <- scale(x)) # all 1
x
?cov
swirl
swirl()
library(swirl)
ls()
rm(list=ls())
?rpois
set.seed(1)
rpois(5, 2)
set.seed(1)
rpois(5, 2)
set.seed(1)
rpois(5, 2)
set.seed(2)
rpois(5, 2)
set.seed(1)
rpois(5, 2)
?rnorm
set.seed(10)
x <- rep(0:1, each = 5)
e <- rnorm(10, 0, 20)
y <- 0.5 + 2 * x + e
plot(x,y)
plot(y,x)
?is
is(x,int)
is(x,numeric)
is(x)
is.na(x)
is.numeric(x)
?numeric
?factor
?str
summary(x)
str(x)
ls()
?rm
rm(ls())
list=ls()
rm(list)
rm(list=ls())
rm
?.Primitive
list <- .Primitive("c")(list, names)
list
?character
characer(a)
character(a)
character('a')
character("a")
characer(1)
character(1)
install.packages('devtools')
devtools::install_github('rstudio/shinyapps')
shinyapps::setAccountInfo(name='ehullander', token='35440152C0F469AB3F255A1152065510', secret='0f6FxqDmAVAKHLBCJ0w/1LJZEPbM8zFt9QQAC+r+')
© CC 2015 RStudio, Inc.
library(shiny)
require("googleVis")
DF <- read.csv("tweetscores.csv", colClasses = "character")
DF<-DF[DF$X!="",]
DF$date<-factor(DF$date)
dates<-unique(as.character(DF$date))
#week<-weekdays(as.Date(dates))
ui <- fluidPage(
selectInput(inputId = "when",
label= "Date:",
dates, selected = dates[1]),
numericInput(inputId = "qty",
label="MinTweets",
value=30),
mainPanel(
htmlOutput("gvis")
)
)
server <- function(input, output) {
df<- reactive({
rbind(rbind(subset(DF,date==input$when & as.numeric(count)>input$qty),
c(X=1301, DMA=1301,scores= 0, sd=0,count=0,Region=0, input$when)),
c(X=1301, DMA=1301,scores= 0, sd=0,count=0,Region=0, input$when))
})
output$gvis <- renderGvis({
gvisGeoChart(df(), "DMA", "scores", hovervar = "Region",
options=list(region="US", displayMode="regions",
resolution="metros",
colors="['#0033CC','#999999','#FFFF00']"))
})
}
shinyApp(ui = ui, server = server)
© CC 2015 RStudio, Inc.
library(shiny)
require("googleVis")
DF <- read.csv("tweetscores.csv", colClasses = "character")
DF<-DF[DF$X!="",]
DF$date<-factor(DF$date)
dates<-unique(as.character(DF$date))
#week<-weekdays(as.Date(dates))
ui <- fluidPage(
selectInput(inputId = "when",
label= "Date:",
dates, selected = dates[1]),
numericInput(inputId = "qty",
label="MinTweets",
value=30),
mainPanel(
htmlOutput("gvis")
)
)
server <- function(input, output) {
df<- reactive({
rbind(rbind(subset(DF,date==input$when & as.numeric(count)>input$qty),
c(X=1301, DMA=1301,scores= 0, sd=0,count=0,Region=0, input$when)),
c(X=1301, DMA=1301,scores= 0, sd=0,count=0,Region=0, input$when))
})
output$gvis <- renderGvis({
gvisGeoChart(df(), "DMA", "scores", hovervar = "Region",
options=list(region="US", displayMode="regions",
resolution="metros",
colors="['#0033CC','#999999','#FFFF00']"))
})
}
shinyApp(ui = ui, server = server)
detach("package:googleVis", unload=TRUE)
library("googleVis", lib.loc="~/R/win-library/3.2")
setwd("C:/Users/Eric/Desktop/Learning/Python/Twitterstream/Twitterstream/App")
© CC 2015 RStudio, Inc.
library(shiny)
require("googleVis")
DF <- read.csv("tweetscores.csv", colClasses = "character")
DF<-DF[DF$X!="",]
DF$date<-factor(DF$date)
dates<-unique(as.character(DF$date))
#week<-weekdays(as.Date(dates))
ui <- fluidPage(
selectInput(inputId = "when",
label= "Date:",
dates, selected = dates[1]),
numericInput(inputId = "qty",
label="MinTweets",
value=30),
mainPanel(
htmlOutput("gvis")
)
)
server <- function(input, output) {
df<- reactive({
rbind(rbind(subset(DF,date==input$when & as.numeric(count)>input$qty),
c(X=1301, DMA=1301,scores= 0, sd=0,count=0,Region=0, input$when)),
c(X=1301, DMA=1301,scores= 0, sd=0,count=0,Region=0, input$when))
})
output$gvis <- renderGvis({
gvisGeoChart(df(), "DMA", "scores", hovervar = "Region",
options=list(region="US", displayMode="regions",
resolution="metros",
colors="['#0033CC','#999999','#FFFF00']"))
})
}
shinyApp(ui = ui, server = server)
© CC 2015 RStudio, Inc.
library(shiny)
require("googleVis")
DF <- read.csv("tweetscores.csv", colClasses = "character")
DF<-DF[DF$X!="",]
DF$date<-factor(DF$date)
dates<-unique(as.character(DF$date))
#week<-weekdays(as.Date(dates))
ui <- fluidPage(
selectInput(inputId = "when",
label= "Date:",
dates, selected = dates[1]),
numericInput(inputId = "qty",
label="MinTweets",
value=30),
mainPanel(
htmlOutput("gvis")
)
)
server <- function(input, output) {
df<- reactive({
rbind(rbind(subset(DF,date==input$when & as.numeric(count)>input$qty),
c(X=1301, DMA=1301,scores= 0, sd=0,count=0,Region=0, input$when)),
c(X=1301, DMA=1301,scores= 0, sd=0,count=0,Region=0, input$when))
})
output$gvis <- renderGvis({
gvisGeoChart(df(), "DMA", "scores", hovervar = "Region",
options=list(region="US", displayMode="regions",
resolution="metros",
colors="['#0033CC','#999999','#FFFF00']"))
})
}
shinyApp(ui = ui, server = server)
?setAccountInfo
setAccountInfo("ehullander", "35440152C0F469AB3F255A1152065510",secret='0f6FxqDmAVAKHLBCJ0w/1LJZEPbM8zFt9QQAC+r+')
?setAccountInfo
setAccountInfo
setAccountInfo()
install(shinyapps)
library(shinyapps)
setAccountInfo("ehullander", "35440152C0F469AB3F255A1152065510",secret='0f6FxqDmAVAKHLBCJ0w/1LJZEPbM8zFt9QQAC+r+')
© CC 2015 RStudio, Inc.
library(shiny)
require("googleVis")
DF <- read.csv("tweetscores.csv", colClasses = "character")
DF<-DF[DF$X!="",]
DF$date<-factor(DF$date)
dates<-unique(as.character(DF$date))
#week<-weekdays(as.Date(dates))
ui <- fluidPage(
selectInput(inputId = "when",
label= "Date:",
dates, selected = dates[1]),
numericInput(inputId = "qty",
label="MinTweets",
value=30),
mainPanel(
htmlOutput("gvis")
)
)
server <- function(input, output) {
df<- reactive({
rbind(rbind(subset(DF,date==input$when & as.numeric(count)>input$qty),
c(X=1301, DMA=1301,scores= 0, sd=0,count=0,Region=0, input$when)),
c(X=1301, DMA=1301,scores= 0, sd=0,count=0,Region=0, input$when))
})
output$gvis <- renderGvis({
gvisGeoChart(df(), "DMA", "scores", hovervar = "Region",
options=list(region="US", displayMode="regions",
resolution="metros",
colors="['#0033CC','#999999','#FFFF00']"))
})
}
shinyApp(ui = ui, server = server)
shinyapps::setAccountInfo(name='ehullander',
token='640440FAC4ED22B5917E1BD151A44098',
secret='<SECRET>')
shinyapps::setAccountInfo(name='ehullander', token='640440FAC4ED22B5917E1BD151A44098', secret='KpnSX+vpuH4XvTT4VeejB4VC+ot7TeOR9SvQUJq4')
© CC 2015 RStudio, Inc.
library(shiny)
require("googleVis")
DF <- read.csv("tweetscores.csv", colClasses = "character")
DF<-DF[DF$X!="",]
DF$date<-factor(DF$date)
dates<-unique(as.character(DF$date))
#week<-weekdays(as.Date(dates))
ui <- fluidPage(
selectInput(inputId = "when",
label= "Date:",
dates, selected = dates[1]),
numericInput(inputId = "qty",
label="MinTweets",
value=30),
mainPanel(
htmlOutput("gvis")
)
)
server <- function(input, output) {
df<- reactive({
rbind(rbind(subset(DF,date==input$when & as.numeric(count)>input$qty),
c(X=1301, DMA=1301,scores= 0, sd=0,count=0,Region=0, input$when)),
c(X=1301, DMA=1301,scores= 0, sd=0,count=0,Region=0, input$when))
})
output$gvis <- renderGvis({
gvisGeoChart(df(), "DMA", "scores", hovervar = "Region",
options=list(region="US", displayMode="regions",
resolution="metros",
colors="['#0033CC','#999999','#FFFF00']"))
})
}
shinyApp(ui = ui, server = server)
shinyapps::setAccountInfo(name='ehullander', token='640440FAC4ED22B5917E1BD151A44098', secret='KpnSX+vpuH4XvTT4VeejB4VC+ot7TeOR9SvQUJq4')
© CC 2015 RStudio, Inc.
library(shiny)
require("googleVis")
DF <- read.csv("tweetscores.csv", colClasses = "character")
DF<-DF[DF$X!="",]
DF$date<-factor(DF$date)
dates<-unique(as.character(DF$date))
#week<-weekdays(as.Date(dates))
ui <- fluidPage(
selectInput(inputId = "when",
label= "Date:",
dates, selected = dates[1]),
numericInput(inputId = "qty",
label="MinTweets",
value=30),
mainPanel(
htmlOutput("gvis")
)
)
server <- function(input, output) {
df<- reactive({
rbind(rbind(subset(DF,date==input$when & as.numeric(count)>input$qty),
c(X=1301, DMA=1301,scores= 0, sd=0,count=0,Region=0, input$when)),
c(X=1301, DMA=1301,scores= 0, sd=0,count=0,Region=0, input$when))
})
output$gvis <- renderGvis({
gvisGeoChart(df(), "DMA", "scores", hovervar = "Region",
options=list(region="US", displayMode="regions",
resolution="metros",
colors="['#0033CC','#999999','#FFFF00']"))
})
}
shinyApp(ui = ui, server = server)
x<-getwd()
library(shinyapps)
shinyapps::deployApp(x)
x
library(shinyapps)
shinyapps::deployApp('Users/Eric/Desktop/Learning/Python/Twitterstream/Twitterstream/App')
library(shinyapps)
shinyapps::deployApp('')
library(shinyapps)
shinyapps::deployApp('App')
library(shinyapps)
shinyapps::deployApp()
library(shinyapps)
shinyapps::deployApp('MoodMap')
library(shinyapps)
shinyapps::deployApp('App.R')
library(shinyapps)
shinyapps::deployApp('path/to/your/app')
library(shinyapps)
shinyapps::deployApp()
